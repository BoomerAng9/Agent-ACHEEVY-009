/**
 * File Generation & Download API — /api/files/generate
 *
 * Generates downloadable files from agent outputs. Supports:
 *   - Markdown (.md) — research reports, analysis
 *   - JSON (.json) — structured data, configs
 *   - CSV (.csv) — data exports, tables
 *   - Plain text (.txt) — logs, scripts
 *   - HTML (.html) — generated pages, reports
 *
 * Closes Gap G4: File Generation & Download
 *
 * Request:
 *   POST { content: string, format: string, filename?: string, metadata?: object }
 *
 * Response:
 *   Binary file download with appropriate Content-Type + Content-Disposition
 */

import { NextRequest, NextResponse } from 'next/server';

const ALLOWED_FORMATS = ['md', 'json', 'csv', 'txt', 'html'] as const;
type FileFormat = (typeof ALLOWED_FORMATS)[number];

const MIME_TYPES: Record<FileFormat, string> = {
  md: 'text/markdown',
  json: 'application/json',
  csv: 'text/csv',
  txt: 'text/plain',
  html: 'text/html',
};

const MAX_CONTENT_SIZE = 5_000_000; // 5MB max

function sanitizeFilename(name: string): string {
  return name.replace(/[^a-zA-Z0-9._-]/g, '_').slice(0, 200);
}

export async function POST(request: NextRequest) {
  try {
    const body = await request.json();
    const { content, format = 'md', filename, metadata } = body;

    // Validate content
    if (!content || typeof content !== 'string') {
      return NextResponse.json({ error: 'content is required and must be a string' }, { status: 400 });
    }
    if (content.length > MAX_CONTENT_SIZE) {
      return NextResponse.json({ error: `Content exceeds ${MAX_CONTENT_SIZE} byte limit` }, { status: 400 });
    }

    // Validate format
    if (!ALLOWED_FORMATS.includes(format as FileFormat)) {
      return NextResponse.json(
        { error: `Invalid format: ${format}. Allowed: ${ALLOWED_FORMATS.join(', ')}` },
        { status: 400 },
      );
    }

    // Generate filename
    const timestamp = new Date().toISOString().slice(0, 10);
    const baseName = filename
      ? sanitizeFilename(filename)
      : `aims-${metadata?.type || 'export'}-${timestamp}`;
    const fullFilename = baseName.endsWith(`.${format}`) ? baseName : `${baseName}.${format}`;

    // Process content based on format
    let outputContent = content;

    if (format === 'json') {
      // If content is a string that looks like JSON, validate it
      try {
        JSON.parse(content);
      } catch {
        // Wrap in a JSON envelope if it's not valid JSON
        outputContent = JSON.stringify({
          generated: new Date().toISOString(),
          source: 'AIMS Platform',
          metadata: metadata || {},
          content,
        }, null, 2);
      }
    }

    if (format === 'html') {
      // Wrap in a basic HTML template if it doesn't have <html> tag
      if (!content.includes('<html')) {
        outputContent = `<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>${baseName}</title>
  <style>
    body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif; max-width: 800px; margin: 2rem auto; padding: 0 1rem; color: #333; line-height: 1.6; }
    h1, h2, h3 { color: #1a1a1a; }
    code { background: #f5f5f5; padding: 2px 6px; border-radius: 3px; font-size: 0.9em; }
    pre { background: #f5f5f5; padding: 1rem; border-radius: 6px; overflow-x: auto; }
    table { border-collapse: collapse; width: 100%; }
    th, td { border: 1px solid #ddd; padding: 8px 12px; text-align: left; }
    th { background: #f5f5f5; }
    .footer { margin-top: 3rem; padding-top: 1rem; border-top: 1px solid #eee; font-size: 0.8rem; color: #999; }
  </style>
</head>
<body>
${content}
<div class="footer">Generated by A.I.M.S. &mdash; ${new Date().toISOString()}</div>
</body>
</html>`;
      }
    }

    if (format === 'md') {
      // Add AIMS header if content doesn't start with #
      if (!content.trim().startsWith('#')) {
        outputContent = `# ${baseName}\n\n> Generated by A.I.M.S. on ${new Date().toISOString()}\n\n${content}`;
      }
    }

    // Return as a downloadable file
    const mimeType = MIME_TYPES[format as FileFormat];
    const blob = new Blob([outputContent], { type: mimeType });
    const arrayBuffer = await blob.arrayBuffer();

    return new Response(arrayBuffer, {
      headers: {
        'Content-Type': mimeType,
        'Content-Disposition': `attachment; filename="${fullFilename}"`,
        'Content-Length': String(arrayBuffer.byteLength),
        'X-AIMS-Generated': 'true',
        'X-AIMS-Format': format,
      },
    });
  } catch (error: unknown) {
    const message = error instanceof Error ? error.message : 'File generation failed';
    console.error('[FileGen]', message);
    return NextResponse.json({ error: message }, { status: 500 });
  }
}

/**
 * GET — List available export formats
 */
export async function GET() {
  return NextResponse.json({
    formats: ALLOWED_FORMATS.map(f => ({
      extension: f,
      mimeType: MIME_TYPES[f],
      description: {
        md: 'Markdown document',
        json: 'JSON data',
        csv: 'Comma-separated values',
        txt: 'Plain text',
        html: 'HTML document',
      }[f],
    })),
    maxSize: MAX_CONTENT_SIZE,
  });
}
